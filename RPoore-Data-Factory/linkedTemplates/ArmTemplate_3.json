{
	"$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
	"contentVersion": "1.0.0.0",
	"parameters": {
		"factoryName": {
			"type": "string",
			"metadata": "Data Factory name",
			"defaultValue": "RPoore-Data-Factory"
		}
	},
	"variables": {
		"factoryId": "[concat('Microsoft.DataFactory/factories/', parameters('factoryName'))]"
	},
	"resources": [
		{
			"name": "[concat(parameters('factoryName'), '/CodeTableHeader')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "SQLRMLAPTOP610",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Curam"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "TABLENAME",
						"type": "char"
					},
					{
						"name": "TIMEENTERED",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "DEFAULTCODE",
						"type": "char"
					},
					{
						"name": "PARENTCODETABLE",
						"type": "char"
					},
					{
						"name": "VERSIONNO",
						"type": "int",
						"precision": 10
					},
					{
						"name": "LASTWRITTEN",
						"type": "datetime2",
						"scale": 7
					}
				],
				"typeProperties": {
					"schema": "CURAPD01",
					"table": "CODETABLEHEADER"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/CodeTableItem')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "SQLRMLAPTOP610",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Curam"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "TABLENAME",
						"type": "char"
					},
					{
						"name": "CODE",
						"type": "char"
					},
					{
						"name": "DESCRIPTION",
						"type": "varchar"
					},
					{
						"name": "ANNOTATION",
						"type": "varchar"
					},
					{
						"name": "ISENABLED",
						"type": "char"
					},
					{
						"name": "SORTORDER",
						"type": "int",
						"precision": 10
					},
					{
						"name": "LOCALEIDENTIFIER",
						"type": "char"
					},
					{
						"name": "PARENTCODE",
						"type": "char"
					},
					{
						"name": "COMMENTS",
						"type": "varchar"
					},
					{
						"name": "VERSIONNO",
						"type": "int",
						"precision": 10
					},
					{
						"name": "LASTWRITTEN",
						"type": "datetime2",
						"scale": 7
					}
				],
				"typeProperties": {
					"schema": "CURAPD01",
					"table": "CODETABLEITEM"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/MetadataDrivenCopyTask_di4_ControlDS')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "SQLRMLAPTOP610",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "ODS/MetadataCopyTask/MetadataDrivenCopyTask_di4_20220829"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [],
				"typeProperties": {
					"schema": "dbo",
					"table": "MainControlTable_di4"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/MetadataDrivenCopyTask_di4_SourceDS')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "SQLRMLAPTOP610",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"cw_schema": {
						"type": "String"
					},
					"cw_table": {
						"type": "String"
					}
				},
				"folder": {
					"name": "ODS/MetadataCopyTask/MetadataDrivenCopyTask_di4_20220829"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [],
				"typeProperties": {
					"schema": {
						"value": "@dataset().cw_schema",
						"type": "Expression"
					},
					"table": {
						"value": "@dataset().cw_table",
						"type": "Expression"
					}
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/MetadataDrivenCopyTask_fgf_ControlDS')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "SQLRMLAPTOP610",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "ODS/MetadataCopyTask/MetadataDrivenCopyTask_fgf_20220829"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [],
				"typeProperties": {
					"schema": "dbo",
					"table": "MainControlTable_fgf"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/MetadataDrivenCopyTask_fgf_SourceDS')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "SQLRMLAPTOP610",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"cw_schema": {
						"type": "String"
					},
					"cw_table": {
						"type": "String"
					}
				},
				"folder": {
					"name": "ODS/MetadataCopyTask/MetadataDrivenCopyTask_fgf_20220829"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [],
				"typeProperties": {
					"schema": {
						"value": "@dataset().cw_schema",
						"type": "Expression"
					},
					"table": {
						"value": "@dataset().cw_table",
						"type": "Expression"
					}
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/MetadataDrivenCopyTask_vrc_ControlDS')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "SQLRMLAPTOP610",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "ODS/MetadataCopyTask/MetadataDrivenCopyTask_vrc_20220829"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [],
				"typeProperties": {
					"schema": "dbo",
					"table": "MainControlTable_vrc"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/MetadataDrivenCopyTask_vrc_SourceDS')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "SQLRMLAPTOP610",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"cw_schema": {
						"type": "String"
					},
					"cw_table": {
						"type": "String"
					}
				},
				"folder": {
					"name": "ODS/MetadataCopyTask/MetadataDrivenCopyTask_vrc_20220829"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [],
				"typeProperties": {
					"schema": {
						"value": "@dataset().cw_schema",
						"type": "Expression"
					},
					"table": {
						"value": "@dataset().cw_table",
						"type": "Expression"
					}
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/SDDenormalizedecision')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "SQLRMLAPTOP610",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Curam"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "SDDENORMALIZEDDECISIONID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "INTEGRATEDCASEID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "PRODUCTDELIVERYCASEID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "PARTICIPANTID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "CREOLECASEDETERMINATIONID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "TIMELINESTARTDATE",
						"type": "date"
					},
					{
						"name": "TIMELINEENDDATE",
						"type": "date"
					},
					{
						"name": "ISELIGIBLE",
						"type": "char"
					},
					{
						"name": "PRODUCTID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "CASEDECISIONSTATUSCODE",
						"type": "char"
					},
					{
						"name": "ISHOUSEHOLDMEMBERELIGIBLE",
						"type": "char"
					},
					{
						"name": "BENEFITAMOUNT",
						"type": "decimal",
						"precision": 18,
						"scale": 0
					},
					{
						"name": "AIDCODE",
						"type": "char"
					},
					{
						"name": "RECORDSTATUS",
						"type": "char"
					},
					{
						"name": "RULEOBJECTSNAPSHOTDATAID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "UNEARNEDINCOME",
						"type": "decimal",
						"precision": 18,
						"scale": 0
					},
					{
						"name": "EARNEDINCOME",
						"type": "decimal",
						"precision": 18,
						"scale": 0
					},
					{
						"name": "SELFEMPLOYMENTINCOME",
						"type": "decimal",
						"precision": 18,
						"scale": 0
					},
					{
						"name": "INCOMEDEDUCTIONS",
						"type": "decimal",
						"precision": 18,
						"scale": 0
					},
					{
						"name": "NETINDIVIDUALINCOME",
						"type": "decimal",
						"precision": 18,
						"scale": 0
					},
					{
						"name": "ADJUSTEDGROSSINCOME",
						"type": "decimal",
						"precision": 18,
						"scale": 0
					},
					{
						"name": "HOUSEHOLDSIZE",
						"type": "int",
						"precision": 10
					},
					{
						"name": "SDCOVERAGECODE",
						"type": "char"
					},
					{
						"name": "SDCOPAYVALUE",
						"type": "decimal",
						"precision": 18,
						"scale": 0
					},
					{
						"name": "SDMONTHLYGROSSINCOME",
						"type": "decimal",
						"precision": 18,
						"scale": 0
					},
					{
						"name": "SDISRETROACTIVE",
						"type": "char"
					},
					{
						"name": "SDPOVERTYLEVEL",
						"type": "int",
						"precision": 10
					},
					{
						"name": "SDMEMBERPERCENTPOVERTYLEVEL",
						"type": "decimal",
						"precision": 18,
						"scale": 0
					},
					{
						"name": "SDMEMBERCREDITABLEINCOME",
						"type": "decimal",
						"precision": 18,
						"scale": 0
					},
					{
						"name": "SDISPREGNANT",
						"type": "char"
					},
					{
						"name": "SDMAGIHOUSEHOLDSIZE",
						"type": "int",
						"precision": 10
					},
					{
						"name": "SDMAGIMONTHLYHOUSEHOLDINCOME",
						"type": "decimal",
						"precision": 18,
						"scale": 0
					},
					{
						"name": "SDSTATEHOUSEHOLDSIZE",
						"type": "int",
						"precision": 10
					},
					{
						"name": "SDSTATEMONTHLYHOUSEHOLDINCOME",
						"type": "decimal",
						"precision": 18,
						"scale": 0
					},
					{
						"name": "TOTALSHAREOFCOSTAMOUNT",
						"type": "decimal",
						"precision": 18,
						"scale": 0
					},
					{
						"name": "LASTWRITTEN",
						"type": "datetime",
						"precision": 23,
						"scale": 3
					},
					{
						"name": "ISUTILIZINGALLBENEFITS",
						"type": "char"
					},
					{
						"name": "LOTTERWINNINGSAMOUNT",
						"type": "decimal",
						"precision": 18,
						"scale": 0
					},
					{
						"name": "UNCOMPENSATEDIRTAMOUNT",
						"type": "decimal",
						"precision": 18,
						"scale": 0
					},
					{
						"name": "DAILYPRIVATEPAYRATE",
						"type": "decimal",
						"precision": 18,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "CURAPD01",
					"table": "SDDENORMALIZEDDECISION"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/SourceDataset_qt6')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "SQLRMLAPTOP610",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"cw_table": {
						"type": "String"
					}
				},
				"folder": {
					"name": "POCWork"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [],
				"typeProperties": {
					"schema": "CURAPD01",
					"table": {
						"value": "@dataset().cw_table",
						"type": "Expression"
					}
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/DimEmployeeLoaderWorkingExampleFromADF')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "EmployeeFiles1",
								"type": "DatasetReference"
							},
							"name": "Employees1",
							"description": " Source employees file, changes every day"
						},
						{
							"dataset": {
								"referenceName": "DimEmp1",
								"type": "DatasetReference"
							},
							"name": "DimEmployees",
							"description": "Current rows in DimEmployees DW table"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "DimEmp1",
								"type": "DatasetReference"
							},
							"name": "sinkNew",
							"description": " "
						},
						{
							"dataset": {
								"referenceName": "DimEmp1",
								"type": "DatasetReference"
							},
							"name": "sinkUpdates",
							"description": " "
						},
						{
							"dataset": {
								"referenceName": "DimEmp1",
								"type": "DatasetReference"
							},
							"name": "sinkInactive",
							"description": " Age out old rows"
						}
					],
					"transformations": [
						{
							"name": "TypeConversions"
						},
						{
							"name": "TypeConversionsAndSetAttrs"
						},
						{
							"name": "LookupIDs"
						},
						{
							"name": "ConditionalSplit1"
						},
						{
							"name": "checkForChanges"
						},
						{
							"name": "SetAttrsForNew"
						},
						{
							"name": "SetAttrsInactive",
							"description": "make iscurrent 0"
						},
						{
							"name": "SetAttrsUpdate"
						},
						{
							"name": "NormNames"
						},
						{
							"name": "InactiveFields"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "NullFilter",
							"description": "Filter out NULLs from source file"
						},
						{
							"name": "NameNorm2"
						}
					],
					"scriptLines": [
						"source(output(",
						"          EmpID as string,",
						"          Region as string,",
						"          Status as string,",
						"          Function as string,",
						"          Level as string,",
						"          Role as string,",
						"          StartDate as string,",
						"          EndDate as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     purgeFiles: true) ~> Employees1",
						"source(output(",
						"          EmpID as integer,",
						"          surrogatekey as string,",
						"          Region as string,",
						"          Status as string,",
						"          EmpFunction as string,",
						"          Level as string,",
						"          Role as string,",
						"          StartDate as date,",
						"          EndDate as date,",
						"          iscurrent as integer,",
						"          processtime as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> DimEmployees",
						"DimEmployees derive(EmpID = toInteger(EmpID)) ~> TypeConversions",
						"NullFilter derive(EmpID = toInteger(EmpID),",
						"          StartDate = toDate(StartDate,'MM/dd/yyyy'),",
						"          EndDate = toDate(EndDate,'MM/dd/yyyy'),",
						"          processtime = currentTimestamp()) ~> TypeConversionsAndSetAttrs",
						"TypeConversionsAndSetAttrs, TypeConversions lookup(TypeConversionsAndSetAttrs@EmpID == TypeConversions@EmpID,",
						"     multiple: true,",
						"     broadcast: 'auto')~> LookupIDs",
						"NormNames split(isNull(iscurrent),",
						"     disjoint: false) ~> ConditionalSplit1@(NewRow, CheckForUpdates)",
						"NameNorm2, TypeConversions exists(NameNorm2@EmpID == TypeConversions@EmpID,",
						"     negate:false,",
						"     broadcast: 'auto')~> checkForChanges",
						"ConditionalSplit1@NewRow derive(iscurrent = 1,",
						"          surrogatekey = toString(crc32(EmpID,EmpFunction))) ~> SetAttrsForNew",
						"checkForChanges derive(iscurrent = 0) ~> SetAttrsInactive",
						"checkForChanges derive(iscurrent = 1) ~> SetAttrsUpdate",
						"LookupIDs select(mapColumn(",
						"          EmpID = TypeConversionsAndSetAttrs@EmpID,",
						"          Region = Employees1@Region,",
						"          Status = Employees1@Status,",
						"          Level = Employees1@Level,",
						"          Role = Employees1@Role,",
						"          StartDate = TypeConversionsAndSetAttrs@StartDate,",
						"          EndDate = TypeConversionsAndSetAttrs@EndDate,",
						"          EmpFunction = Function,",
						"          iscurrent,",
						"          processtime = TypeConversionsAndSetAttrs@processtime,",
						"          surrogatekey",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> NormNames",
						"SetAttrsInactive select(mapColumn(",
						"          EmpID,",
						"          Status,",
						"          EndDate,",
						"          iscurrent,",
						"          processtime",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> InactiveFields",
						"InactiveFields alterRow(updateIf(true())) ~> AlterRow1",
						"Employees1 filter(!isNull(EmpID)) ~> NullFilter",
						"ConditionalSplit1@CheckForUpdates select(mapColumn(",
						"          EmpID,",
						"          Region,",
						"          Status,",
						"          Level,",
						"          Role,",
						"          StartDate,",
						"          EndDate,",
						"          EmpFunction,",
						"          iscurrent,",
						"          processtime,",
						"          surrogatekey",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> NameNorm2",
						"SetAttrsForNew sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          EmpID as integer,",
						"          surrogatekey as string,",
						"          Region as string,",
						"          Status as string,",
						"          EmpFunction as string,",
						"          Level as string,",
						"          Role as string,",
						"          StartDate as date,",
						"          EndDate as date,",
						"          iscurrent as integer,",
						"          processtime as timestamp",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     batchSize: 50,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     partitionBy('roundRobin', 4)) ~> sinkNew",
						"SetAttrsUpdate sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          EmpID as integer,",
						"          surrogatekey as string,",
						"          Region as string,",
						"          Status as string,",
						"          EmpFunction as string,",
						"          Level as string,",
						"          Role as string,",
						"          StartDate as date,",
						"          EndDate as date,",
						"          iscurrent as integer,",
						"          processtime as timestamp",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     batchSize: 50,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     partitionBy('roundRobin', 4)) ~> sinkUpdates",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          EmpID as integer,",
						"          surrogatekey as string,",
						"          Region as string,",
						"          Status as string,",
						"          EmpFunction as string,",
						"          Level as string,",
						"          Role as string,",
						"          StartDate as date,",
						"          EndDate as date,",
						"          iscurrent as integer,",
						"          processtime as timestamp",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['EmpID'],",
						"     format: 'table',",
						"     batchSize: 50,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          EmpID,",
						"          EndDate,",
						"          iscurrent,",
						"          processtime",
						"     ),",
						"     partitionBy('roundRobin', 4)) ~> sinkInactive"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/SCD2_BILearn')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "TestDataForEmployee",
								"type": "DatasetReference"
							},
							"name": "srcEmployee"
						},
						{
							"dataset": {
								"referenceName": "TestDataForEmployeeDim",
								"type": "DatasetReference"
							},
							"name": "srcEmployeeDim"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "TestDataForEmployeeDim",
								"type": "DatasetReference"
							},
							"name": "SinkEmployeeDimInsert"
						},
						{
							"dataset": {
								"referenceName": "TestDataForEmployeeDim",
								"type": "DatasetReference"
							},
							"name": "SinkEmployeeDimUpdate"
						}
					],
					"transformations": [
						{
							"name": "HASHInput"
						},
						{
							"name": "HASHRef"
						},
						{
							"name": "SetToActive"
						},
						{
							"name": "ExistsCheckforUpdates"
						},
						{
							"name": "ExistsCheckforObsolete"
						},
						{
							"name": "SetToInActive"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "SelectColumns"
						},
						{
							"name": "FilterForTesting"
						}
					],
					"script": "source(output(\n\t\tEmpID as short,\n\t\tFirstName as string,\n\t\tLastName as string,\n\t\tMiddleName as string,\n\t\tTitle as string,\n\t\tHireDate as date,\n\t\tBirthDate as date,\n\t\tPhone as string,\n\t\tMaritalStatus as string,\n\t\tEmergencyContactName as string,\n\t\tEmergencyContactPhone as string,\n\t\tSalariedFlag as boolean,\n\t\tGender as string,\n\t\tDepartmentName as string,\n\t\tStartDate as date,\n\t\tEndDate as string,\n\t\tStatus as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table',\n\twildcardPaths:['2021/*.csv']) ~> srcEmployee\nsource(output(\n\t\tEmployeeKey as integer,\n\t\tEmpID as short,\n\t\tFirstName as string,\n\t\tLastName as string,\n\t\tMiddleName as string,\n\t\tTitle as string,\n\t\tHireDate as date,\n\t\tBirthDate as date,\n\t\tPhone as string,\n\t\tMaritalStatus as string,\n\t\tEmergencyContactName as string,\n\t\tEmergencyContactPhone as string,\n\t\tSalariedFlag as boolean,\n\t\tGender as string,\n\t\tDepartmentName as string,\n\t\tStartDate as date,\n\t\tEndDate as string,\n\t\tStatus as string,\n\t\tIsActive as integer\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> srcEmployeeDim\nSelectColumns derive(inputhash = md5(EmpID,LastName,Title,Phone,MaritalStatus,SalariedFlag,DepartmentName)) ~> HASHInput\nsrcEmployeeDim derive(sqlhash = md5(EmpID,LastName,Title,Phone,MaritalStatus,SalariedFlag,DepartmentName)) ~> HASHRef\nExistsCheckforUpdates derive(IsActive = 1,\n\t\tEndDate = toDate('9999-12-31')) ~> SetToActive\nHASHInput, HASHRef exists(inputhash == sqlhash,\n\tnegate:true,\n\tbroadcast: 'auto')~> ExistsCheckforUpdates\nHASHRef, SetToActive exists(srcEmployeeDim@EmpID == SelectColumns@EmpID,\n\tnegate:false,\n\tbroadcast: 'auto')~> ExistsCheckforObsolete\nExistsCheckforObsolete derive(EndDate = toDate(currentUTC()),\n\t\tIsActive = 0,\n\t\tStatus = 'Termed') ~> SetToInActive\nSetToInActive alterRow(updateIf(true())) ~> AlterRow1\nFilterForTesting select(mapColumn(\n\t\tEmpID,\n\t\tFirstName,\n\t\tLastName,\n\t\tMiddleName,\n\t\tTitle,\n\t\tHireDate,\n\t\tBirthDate,\n\t\tPhone,\n\t\tMaritalStatus,\n\t\tEmergencyContactName,\n\t\tEmergencyContactPhone,\n\t\tSalariedFlag,\n\t\tGender,\n\t\tDepartmentName,\n\t\tStartDate,\n\t\tEndDate,\n\t\tStatus\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectColumns\nsrcEmployee filter(EmpID ==1002) ~> FilterForTesting\nSetToActive sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tEmpID,\n\t\tFirstName,\n\t\tLastName,\n\t\tMiddleName,\n\t\tTitle,\n\t\tHireDate,\n\t\tBirthDate,\n\t\tPhone,\n\t\tMaritalStatus,\n\t\tEmergencyContactName,\n\t\tEmergencyContactPhone,\n\t\tSalariedFlag,\n\t\tGender,\n\t\tDepartmentName,\n\t\tStartDate,\n\t\tEndDate,\n\t\tStatus,\n\t\tIsActive\n\t)) ~> SinkEmployeeDimInsert\nAlterRow1 sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:false,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['EmployeeKey'],\n\tskipKeyWrites:true,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tEmployeeKey,\n\t\tEmpID,\n\t\tFirstName,\n\t\tLastName,\n\t\tMiddleName,\n\t\tTitle,\n\t\tHireDate,\n\t\tBirthDate,\n\t\tPhone,\n\t\tMaritalStatus,\n\t\tEmergencyContactName,\n\t\tEmergencyContactPhone,\n\t\tSalariedFlag,\n\t\tGender,\n\t\tDepartmentName,\n\t\tStartDate,\n\t\tEndDate,\n\t\tStatus,\n\t\tIsActive\n\t)) ~> SinkEmployeeDimUpdate"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/SCDType2_EmployeePOC_TEST')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "POC for SCD Type 2 with Adventure Works Data",
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "stgSourceEmployee",
								"type": "DatasetReference"
							},
							"name": "srcEmployeeData"
						},
						{
							"dataset": {
								"referenceName": "tgtDimEmployee",
								"type": "DatasetReference"
							},
							"name": "tgtDimEmployee"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "tgtDimEmployee",
								"type": "DatasetReference"
							},
							"name": "SinkNewData"
						},
						{
							"dataset": {
								"referenceName": "tgtDimEmployee",
								"type": "DatasetReference"
							},
							"name": "SinkInsertUpdates"
						},
						{
							"dataset": {
								"referenceName": "tgtDimEmployee",
								"type": "DatasetReference"
							},
							"name": "SinkInactive"
						}
					],
					"transformations": [
						{
							"name": "SetIsActive"
						},
						{
							"name": "CheckNewRecords"
						},
						{
							"name": "SelectToRename"
						},
						{
							"name": "CheckForChanges"
						},
						{
							"name": "AddIsActive"
						},
						{
							"name": "ChangeIsActive"
						},
						{
							"name": "SelectInactiveColumns"
						},
						{
							"name": "UpdateColumns"
						},
						{
							"name": "LkpEmployee"
						},
						{
							"name": "SelectColumns"
						},
						{
							"name": "FilterCurrent"
						},
						{
							"name": "SelectSinkColumns"
						}
					],
					"scriptLines": [
						"source(output(",
						"          FirstName as string,",
						"          LastName as string,",
						"          MiddleName as string,",
						"          Title as string,",
						"          HireDate as date,",
						"          BirthDate as date,",
						"          Phone as string,",
						"          MaritalStatus as string,",
						"          EmergencyContactName as string,",
						"          EmergencyContactPhone as string,",
						"          SalariedFlag as boolean,",
						"          Gender as string,",
						"          DepartmentName as string,",
						"          StartDate as date,",
						"          EndDate as date,",
						"          Status as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> srcEmployeeData",
						"source(output(",
						"          EmployeeKey as integer,",
						"          FirstName as string,",
						"          LastName as string,",
						"          MiddleName as string,",
						"          Title as string,",
						"          HireDate as date,",
						"          BirthDate as date,",
						"          Phone as string,",
						"          MaritalStatus as string,",
						"          EmergencyContactName as string,",
						"          EmergencyContactPhone as string,",
						"          SalariedFlag as boolean,",
						"          Gender as string,",
						"          DepartmentName as string,",
						"          StartDate as date,",
						"          EndDate as date,",
						"          Status as string,",
						"          IsActive as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> tgtDimEmployee",
						"CheckNewRecords@NewRecords derive(IsActive = 1) ~> SetIsActive",
						"SelectColumns split(isNull(tgtIsActive),",
						"     disjoint: false) ~> CheckNewRecords@(NewRecords, CheckForUpdates)",
						"CheckNewRecords@CheckForUpdates select(mapColumn(",
						"          FirstName,",
						"          LastName,",
						"          MiddleName,",
						"          Title,",
						"          HireDate,",
						"          BirthDate,",
						"          Phone,",
						"          MaritalStatus,",
						"          EmergencyContactName,",
						"          EmergencyContactPhone,",
						"          SalariedFlag,",
						"          Gender,",
						"          DepartmentName,",
						"          StartDate,",
						"          EndDate,",
						"          Status",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> SelectToRename",
						"SelectToRename, tgtDimEmployee exists(SelectToRename@FirstName ==tgtDimEmployee@FirstName&&\r",
						"SelectToRename@LastName==tgtDimEmployee@LastName&&\r",
						"SelectToRename@BirthDate==tgtDimEmployee@BirthDate&&\r",
						"\r",
						"(\r",
						"SelectToRename@LastName!=tgtDimEmployee@LastName||\r",
						"SelectToRename@Title!=tgtDimEmployee@Title||\r",
						"SelectToRename@Phone!=tgtDimEmployee@Phone||\r",
						"SelectToRename@MaritalStatus!=tgtDimEmployee@MaritalStatus||\r",
						"SelectToRename@SalariedFlag!=tgtDimEmployee@SalariedFlag||\r",
						"SelectToRename@DepartmentName!=tgtDimEmployee@DepartmentName||\r",
						"SelectToRename@EndDate!=tgtDimEmployee@EndDate||\r",
						"SelectToRename@Status!=tgtDimEmployee@Status),",
						"     negate:false,",
						"     broadcast: 'left')~> CheckForChanges",
						"CheckForChanges derive(IsActive = 1) ~> AddIsActive",
						"CheckForChanges derive(drvIsActive = 0,",
						"          drvEndDate = currentDate(),",
						"          drvStatus = 'Termed') ~> ChangeIsActive",
						"ChangeIsActive select(mapColumn(",
						"          EndDate = drvEndDate,",
						"          Status = drvStatus,",
						"          IsActive = drvIsActive,",
						"          FirstName,",
						"          LastName,",
						"          BirthDate",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectInactiveColumns",
						"SelectInactiveColumns alterRow(updateIf(true())) ~> UpdateColumns",
						"FilterCurrent, tgtDimEmployee lookup(srcEmployeeData@FirstName == tgtDimEmployee@FirstName",
						"     && srcEmployeeData@LastName == tgtDimEmployee@LastName",
						"     && srcEmployeeData@BirthDate == tgtDimEmployee@BirthDate,",
						"     multiple: true,",
						"     broadcast: 'right')~> LkpEmployee",
						"LkpEmployee select(mapColumn(",
						"          FirstName = srcEmployeeData@FirstName,",
						"          LastName = srcEmployeeData@LastName,",
						"          MiddleName = srcEmployeeData@MiddleName,",
						"          Title = srcEmployeeData@Title,",
						"          HireDate = srcEmployeeData@HireDate,",
						"          BirthDate = srcEmployeeData@BirthDate,",
						"          Phone = srcEmployeeData@Phone,",
						"          MaritalStatus = srcEmployeeData@MaritalStatus,",
						"          EmergencyContactName = srcEmployeeData@EmergencyContactName,",
						"          EmergencyContactPhone = srcEmployeeData@EmergencyContactPhone,",
						"          SalariedFlag = srcEmployeeData@SalariedFlag,",
						"          Gender = srcEmployeeData@Gender,",
						"          DepartmentName = srcEmployeeData@DepartmentName,",
						"          StartDate = srcEmployeeData@StartDate,",
						"          EndDate = srcEmployeeData@EndDate,",
						"          Status = srcEmployeeData@Status,",
						"          EmployeeKey,",
						"          tgtLastName = tgtDimEmployee@LastName,",
						"          tgtTitle = tgtDimEmployee@Title,",
						"          tgtPhone = tgtDimEmployee@Phone,",
						"          tgtMaritalStatus = tgtDimEmployee@MaritalStatus,",
						"          tgtSalariedFlag = tgtDimEmployee@SalariedFlag,",
						"          tgtDepartmentName = tgtDimEmployee@DepartmentName,",
						"          tgtEndDate = tgtDimEmployee@EndDate,",
						"          tgtStatus = tgtDimEmployee@Status,",
						"          tgtIsActive = IsActive",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectColumns",
						"srcEmployeeData filter(Status=='Current') ~> FilterCurrent",
						"SetIsActive select(mapColumn(",
						"          FirstName,",
						"          LastName,",
						"          MiddleName,",
						"          Title,",
						"          HireDate,",
						"          BirthDate,",
						"          Phone,",
						"          MaritalStatus,",
						"          EmergencyContactName,",
						"          EmergencyContactPhone,",
						"          SalariedFlag,",
						"          Gender,",
						"          DepartmentName,",
						"          StartDate,",
						"          EndDate,",
						"          Status,",
						"          IsActive",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectSinkColumns",
						"SelectSinkColumns sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 1,",
						"     errorHandlingOption: 'stopOnFirstError') ~> SinkNewData",
						"AddIsActive sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 3,",
						"     errorHandlingOption: 'stopOnFirstError') ~> SinkInsertUpdates",
						"UpdateColumns sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['FirstName','LastName','BirthDate'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 2,",
						"     errorHandlingOption: 'stopOnFirstError') ~> SinkInactive"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/SCDType2_EmployeePOC_YouTubeLogic')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "POC for SCD Type 2 with Adventure Works Data",
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "stgSourceEmployee",
								"type": "DatasetReference"
							},
							"name": "srcEmployeeData"
						},
						{
							"dataset": {
								"referenceName": "tgtDimEmployee",
								"type": "DatasetReference"
							},
							"name": "tgtDimEmployee"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "tgtDimEmployee",
								"type": "DatasetReference"
							},
							"name": "SinkUpdates"
						}
					],
					"transformations": [
						{
							"name": "AddIsActive"
						},
						{
							"name": "LkpEmployee"
						},
						{
							"name": "FilterCurrent"
						},
						{
							"name": "filter1"
						},
						{
							"name": "SelectSinkColumns"
						},
						{
							"name": "alterRow1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          FirstName as string,",
						"          LastName as string,",
						"          MiddleName as string,",
						"          Title as string,",
						"          HireDate as date,",
						"          BirthDate as date,",
						"          Phone as string,",
						"          MaritalStatus as string,",
						"          EmergencyContactName as string,",
						"          EmergencyContactPhone as string,",
						"          SalariedFlag as boolean,",
						"          Gender as string,",
						"          DepartmentName as string,",
						"          StartDate as date,",
						"          EndDate as date,",
						"          Status as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> srcEmployeeData",
						"source(output(",
						"          EmployeeKey as integer,",
						"          FirstName as string,",
						"          LastName as string,",
						"          MiddleName as string,",
						"          Title as string,",
						"          HireDate as date,",
						"          BirthDate as date,",
						"          Phone as string,",
						"          MaritalStatus as string,",
						"          EmergencyContactName as string,",
						"          EmergencyContactPhone as string,",
						"          SalariedFlag as boolean,",
						"          Gender as string,",
						"          DepartmentName as string,",
						"          StartDate as date,",
						"          EndDate as date,",
						"          Status as string,",
						"          IsActive as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> tgtDimEmployee",
						"LkpEmployee derive(IsActive = 1) ~> AddIsActive",
						"FilterCurrent, tgtDimEmployee lookup(srcEmployeeData@FirstName == tgtDimEmployee@FirstName",
						"     && srcEmployeeData@LastName == tgtDimEmployee@LastName",
						"     && srcEmployeeData@BirthDate == tgtDimEmployee@BirthDate,",
						"     multiple: true,",
						"     broadcast: 'right')~> LkpEmployee",
						"srcEmployeeData filter(Status=='Current') ~> FilterCurrent",
						"tgtDimEmployee filter(Status=='Current') ~> filter1",
						"AddIsActive select(mapColumn(",
						"          FirstName = srcEmployeeData@FirstName,",
						"          LastName = srcEmployeeData@LastName,",
						"          MiddleName = srcEmployeeData@MiddleName,",
						"          Title = srcEmployeeData@Title,",
						"          HireDate = srcEmployeeData@HireDate,",
						"          BirthDate = srcEmployeeData@BirthDate,",
						"          Phone = srcEmployeeData@Phone,",
						"          MaritalStatus = srcEmployeeData@MaritalStatus,",
						"          EmergencyContactName = srcEmployeeData@EmergencyContactName,",
						"          EmergencyContactPhone = srcEmployeeData@EmergencyContactPhone,",
						"          SalariedFlag = srcEmployeeData@SalariedFlag,",
						"          Gender = srcEmployeeData@Gender,",
						"          DepartmentName = srcEmployeeData@DepartmentName,",
						"          StartDate = srcEmployeeData@StartDate,",
						"          EndDate = srcEmployeeData@EndDate,",
						"          Status = srcEmployeeData@Status,",
						"          IsActive",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectSinkColumns",
						"SelectSinkColumns alterRow(insertIf(true())) ~> alterRow1",
						"alterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError') ~> SinkUpdates"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/SCDType2_EmployeePOC_copy2')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "POC for SCD Type 2 with Adventure Works Data",
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "stgSourceEmployee",
								"type": "DatasetReference"
							},
							"name": "srcEmployeeData"
						},
						{
							"dataset": {
								"referenceName": "tgtDimEmployee",
								"type": "DatasetReference"
							},
							"name": "tgtDimEmployee"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "tgtDimEmployee",
								"type": "DatasetReference"
							},
							"name": "SinkUpdates"
						}
					],
					"transformations": [
						{
							"name": "AddIsActive"
						},
						{
							"name": "LkpEmployee"
						},
						{
							"name": "filter1"
						},
						{
							"name": "SelectSinkColumns"
						},
						{
							"name": "alterRow1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          FirstName as string,",
						"          LastName as string,",
						"          MiddleName as string,",
						"          Title as string,",
						"          HireDate as date,",
						"          BirthDate as date,",
						"          Phone as string,",
						"          MaritalStatus as string,",
						"          EmergencyContactName as string,",
						"          EmergencyContactPhone as string,",
						"          SalariedFlag as boolean,",
						"          Gender as string,",
						"          DepartmentName as string,",
						"          StartDate as date,",
						"          EndDate as date,",
						"          Status as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> srcEmployeeData",
						"source(output(",
						"          EmployeeKey as integer,",
						"          FirstName as string,",
						"          LastName as string,",
						"          MiddleName as string,",
						"          Title as string,",
						"          HireDate as date,",
						"          BirthDate as date,",
						"          Phone as string,",
						"          MaritalStatus as string,",
						"          EmergencyContactName as string,",
						"          EmergencyContactPhone as string,",
						"          SalariedFlag as boolean,",
						"          Gender as string,",
						"          DepartmentName as string,",
						"          StartDate as date,",
						"          EndDate as date,",
						"          Status as string,",
						"          IsActive as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> tgtDimEmployee",
						"LkpEmployee derive(IsActive = 1) ~> AddIsActive",
						"srcEmployeeData, tgtDimEmployee lookup(srcEmployeeData@FirstName == tgtDimEmployee@FirstName",
						"     && srcEmployeeData@LastName == tgtDimEmployee@LastName",
						"     && srcEmployeeData@BirthDate == tgtDimEmployee@BirthDate,",
						"     multiple: true,",
						"     broadcast: 'right')~> LkpEmployee",
						"tgtDimEmployee filter(Status=='Current') ~> filter1",
						"AddIsActive select(mapColumn(",
						"          FirstName = srcEmployeeData@FirstName,",
						"          LastName = srcEmployeeData@LastName,",
						"          MiddleName = srcEmployeeData@MiddleName,",
						"          Title = srcEmployeeData@Title,",
						"          HireDate = srcEmployeeData@HireDate,",
						"          BirthDate = srcEmployeeData@BirthDate,",
						"          Phone = srcEmployeeData@Phone,",
						"          MaritalStatus = srcEmployeeData@MaritalStatus,",
						"          EmergencyContactName = srcEmployeeData@EmergencyContactName,",
						"          EmergencyContactPhone = srcEmployeeData@EmergencyContactPhone,",
						"          SalariedFlag = srcEmployeeData@SalariedFlag,",
						"          Gender = srcEmployeeData@Gender,",
						"          DepartmentName = srcEmployeeData@DepartmentName,",
						"          StartDate = srcEmployeeData@StartDate,",
						"          EndDate = srcEmployeeData@EndDate,",
						"          Status = srcEmployeeData@Status,",
						"          IsActive",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectSinkColumns",
						"SelectSinkColumns alterRow(insertIf(true())) ~> alterRow1",
						"alterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError') ~> SinkUpdates"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_Address')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "Address",
								"type": "DatasetReference"
							},
							"name": "srcAddress"
						},
						{
							"dataset": {
								"referenceName": "AddressIncrmUpdate",
								"type": "DatasetReference"
							},
							"name": "stgAddress"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "AddressIncrmUpdate",
								"type": "DatasetReference"
							},
							"name": "trgtAddress"
						}
					],
					"transformations": [
						{
							"name": "Exists"
						},
						{
							"name": "Upsert"
						},
						{
							"name": "ModifiedDate"
						}
					],
					"scriptLines": [
						"source(output(",
						"          AddressID as integer,",
						"          AddressLine1 as string,",
						"          AddressLine2 as string,",
						"          City as string,",
						"          StateProvince as string,",
						"          CountryRegion as string,",
						"          PostalCode as string,",
						"          rowguid as string,",
						"          ModifiedDate as timestamp",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     enableCdc: true,",
						"     mode: 'read',",
						"     skipInitialLoad: false,",
						"     waterMarkColumn: 'ModifiedDate',",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> srcAddress",
						"source(output(",
						"          AddressID as integer,",
						"          AddressLine1 as string,",
						"          AddressLine2 as string,",
						"          City as string,",
						"          StateProvince as string,",
						"          CountryRegion as string,",
						"          PostalCode as string,",
						"          rowguid as string,",
						"          ModifiedDate as timestamp",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> stgAddress",
						"ModifiedDate, stgAddress exists(srcAddress@AddressID == stgAddress@AddressID,",
						"     negate:true,",
						"     broadcast: 'auto')~> Exists",
						"Exists alterRow(upsertIf(true())) ~> Upsert",
						"srcAddress derive(EDWCreateDate = currentTimestamp()) ~> ModifiedDate",
						"Upsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          AddressID as integer,",
						"          AddressLine1 as string,",
						"          AddressLine2 as string,",
						"          City as string,",
						"          StateProvince as string,",
						"          CountryRegion as string,",
						"          PostalCode as string,",
						"          rowguid as string,",
						"          ModifiedDate as timestamp",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:false,",
						"     upsertable:true,",
						"     keys:['AddressID'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError') ~> trgtAddress"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_Address_SCD')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "POCWork"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "Address",
								"type": "DatasetReference"
							},
							"name": "srcAddress"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_SCD1",
								"type": "DatasetReference"
							},
							"name": "trgtAddressSCD"
						}
					],
					"transformations": [
						{
							"name": "alterRow1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          AddressID as integer,",
						"          AddressLine1 as string,",
						"          AddressLine2 as string,",
						"          City as string,",
						"          StateProvince as string,",
						"          CountryRegion as string,",
						"          PostalCode as string,",
						"          rowguid as string,",
						"          ModifiedDate as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     enableCdc: true,",
						"     mode: 'read',",
						"     skipInitialLoad: false,",
						"     waterMarkColumn: 'ModifiedDate',",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> srcAddress",
						"srcAddress alterRow(upsertIf(1==1)) ~> alterRow1",
						"alterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:false,",
						"     upsertable:true,",
						"     keys:['AddressID'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          AddressID,",
						"          AddressLine1,",
						"          AddressLine2,",
						"          City,",
						"          StateProvince,",
						"          CountryRegion,",
						"          PostalCode,",
						"          rowguid,",
						"          ModifiedDate",
						"     )) ~> trgtAddressSCD"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_Address_copy1')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "Address",
								"type": "DatasetReference"
							},
							"name": "srcAddress"
						},
						{
							"dataset": {
								"referenceName": "AddressIncrmUpdate",
								"type": "DatasetReference"
							},
							"name": "stgAddress"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "AddressIncrmUpdate",
								"type": "DatasetReference"
							},
							"name": "trgtAddress"
						}
					],
					"transformations": [
						{
							"name": "Checksum"
						},
						{
							"name": "Exists"
						},
						{
							"name": "Upsert"
						}
					],
					"scriptLines": [
						"source(output(",
						"          AddressID as integer,",
						"          AddressLine1 as string,",
						"          AddressLine2 as string,",
						"          City as string,",
						"          StateProvince as string,",
						"          CountryRegion as string,",
						"          PostalCode as string,",
						"          rowguid as string,",
						"          ModifiedDate as timestamp",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     enableCdc: true,",
						"     mode: 'read',",
						"     skipInitialLoad: false,",
						"     waterMarkColumn: 'ModifiedDate',",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> srcAddress",
						"source(output(",
						"          AddressID as integer,",
						"          AddressLine1 as string,",
						"          AddressLine2 as string,",
						"          City as string,",
						"          StateProvince as string,",
						"          CountryRegion as string,",
						"          PostalCode as string,",
						"          rowguid as string,",
						"          ModifiedDate as timestamp",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> stgAddress",
						"srcAddress derive(checksum = sha1(AddressLine1,AddressLine2,City,StateProvince,CountryRegion,PostalCode)) ~> Checksum",
						"Checksum, stgAddress exists(checksum == sha1(stgAddress@AddressLine1,stgAddress@AddressLine2,stgAddress@City,stgAddress@StateProvince,stgAddress@CountryRegion,stgAddress@PostalCode),",
						"     negate:true,",
						"     broadcast: 'auto')~> Exists",
						"Exists alterRow(upsertIf(true())) ~> Upsert",
						"Upsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          AddressID as integer,",
						"          AddressLine1 as string,",
						"          AddressLine2 as string,",
						"          City as string,",
						"          StateProvince as string,",
						"          CountryRegion as string,",
						"          PostalCode as string,",
						"          rowguid as string,",
						"          ModifiedDate as timestamp",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:false,",
						"     upsertable:true,",
						"     keys:['AddressID'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError') ~> trgtAddress"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_CaseHeader_Lookups_POC')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Testing"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "CodeTables",
								"type": "DatasetReference"
							},
							"name": "vwCodeTables"
						},
						{
							"dataset": {
								"referenceName": "CaseHeader",
								"type": "DatasetReference"
							},
							"name": "srcCaseHeader"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "Dummy",
								"type": "DatasetReference"
							},
							"name": "DummyFile"
						}
					],
					"transformations": [
						{
							"name": "CaseObjective"
						},
						{
							"name": "CaseStatus"
						},
						{
							"name": "CasePriority"
						},
						{
							"name": "CaseOutcome"
						},
						{
							"name": "CaseCatTypeCode"
						},
						{
							"name": "CaseClassification"
						},
						{
							"name": "CaseTypeCode"
						},
						{
							"name": "SelectCaseColumns"
						},
						{
							"name": "LookupCaseObjective"
						},
						{
							"name": "SelectCaseObjective"
						},
						{
							"name": "LookupStatus"
						},
						{
							"name": "SelectCaseStatus"
						},
						{
							"name": "LookupCasePriority"
						},
						{
							"name": "SelectCasePriority"
						},
						{
							"name": "LookupCaseOutcome"
						},
						{
							"name": "SelectCaseOutcome"
						},
						{
							"name": "LookupTypeCode"
						},
						{
							"name": "SelectCaseCatTypeCode"
						},
						{
							"name": "LookupClassification"
						},
						{
							"name": "SelectClassification"
						},
						{
							"name": "LookupCaseTypeCode"
						},
						{
							"name": "SelectCaseTypeCode"
						},
						{
							"name": "TrimCodeFields"
						}
					],
					"scriptLines": [
						"source(output(",
						"          TABLENAME as string,",
						"          CODE as string,",
						"          DESCRIPTION as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> vwCodeTables",
						"source(output(",
						"          APPEALINDICATOR as string,",
						"          CASEID as long,",
						"          INTEGRATEDCASEID as long,",
						"          CASEREFERENCE as string,",
						"          CASETYPECODE as string,",
						"          CLASSIFICATIONCODE as string,",
						"          EXPECTEDOUTCOME as long,",
						"          ACTUALOUTCOME as string,",
						"          OWNERORGOBJECTLINKID as long,",
						"          VERSIONNO as integer,",
						"          LASTWRITTEN as timestamp,",
						"          INTEGRATEDCASETYPE as string,",
						"          OBJECTIVECODE as string,",
						"          OUTCOMECODE as string,",
						"          PLANID as long,",
						"          PRIORITYCODE as string,",
						"          RECEIVEDDATE as date,",
						"          EFFECTIVEDATE as date,",
						"          STATUSCODE as string,",
						"          ENDDATE as date,",
						"          EXPECTEDENDDATE as date,",
						"          EXPECTEDSTARTDATE as date,",
						"          FIRSTREVIEWDATE as date,",
						"          COMMENTS as string,",
						"          CONCERNROLEID as long,",
						"          REGISTRATIONDATE as date,",
						"          STARTDATE as date,",
						"          DEFAULTCURRENCYTYPECODE as string,",
						"          DEFAULTDELIVERYMETHODTYPE as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> srcCaseHeader",
						"vwCodeTables filter(TABLENAME=='CaseObjective') ~> CaseObjective",
						"vwCodeTables filter(TABLENAME=='CaseStatus') ~> CaseStatus",
						"vwCodeTables filter(TABLENAME=='CasePriority') ~> CasePriority",
						"vwCodeTables filter(TABLENAME=='CaseOutcome') ~> CaseOutcome",
						"vwCodeTables filter(TABLENAME=='CaseCatTypeCode') ~> CaseCatTypeCode",
						"vwCodeTables filter(TABLENAME=='CaseClassification') ~> CaseClassification",
						"vwCodeTables filter(TABLENAME=='CaseTypeCode') ~> CaseTypeCode",
						"TrimCodeFields select(mapColumn(",
						"          APPEALINDICATOR,",
						"          CASEID,",
						"          INTEGRATEDCASEID,",
						"          CASETYPECODE,",
						"          CLASSIFICATIONCODE,",
						"          INTEGRATEDCASETYPE,",
						"          OBJECTIVECODE,",
						"          OUTCOMECODE,",
						"          PRIORITYCODE,",
						"          STATUSCODE",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectCaseColumns",
						"SelectCaseColumns, CaseObjective lookup(OBJECTIVECODE == CODE,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> LookupCaseObjective",
						"LookupCaseObjective select(mapColumn(",
						"          APPEALINDICATOR,",
						"          CASEID,",
						"          CASETYPECODE,",
						"          CLASSIFICATIONCODE,",
						"          OBJECTIVECODE,",
						"          OUTCOMECODE,",
						"          PRIORITYCODE,",
						"          STATUSCODE,",
						"          INTEGRATEDCASETYPE,",
						"          CaseObj_DESCRIPTION = DESCRIPTION",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectCaseObjective",
						"SelectCaseObjective, CaseStatus lookup(STATUSCODE == CODE,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> LookupStatus",
						"LookupStatus select(mapColumn(",
						"          APPEALINDICATOR,",
						"          CASEID,",
						"          CASETYPECODE,",
						"          CLASSIFICATIONCODE,",
						"          OBJECTIVECODE,",
						"          OUTCOMECODE,",
						"          PRIORITYCODE,",
						"          STATUSCODE,",
						"          INTEGRATEDCASETYPE,",
						"          CaseObj_DESCRIPTION,",
						"          CaseStatus_DESCRIPTION = DESCRIPTION",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectCaseStatus",
						"SelectCaseStatus, CasePriority lookup(PRIORITYCODE == CODE,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> LookupCasePriority",
						"LookupCasePriority select(mapColumn(",
						"          APPEALINDICATOR,",
						"          CASEID,",
						"          CASETYPECODE,",
						"          CLASSIFICATIONCODE,",
						"          OBJECTIVECODE,",
						"          OUTCOMECODE,",
						"          PRIORITYCODE,",
						"          STATUSCODE,",
						"          INTEGRATEDCASETYPE,",
						"          CaseObj_DESCRIPTION,",
						"          CaseStatus_DESCRIPTION,",
						"          CasePriority_DESCRIPTION = DESCRIPTION",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectCasePriority",
						"SelectCasePriority, CaseOutcome lookup(OUTCOMECODE == CODE,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> LookupCaseOutcome",
						"LookupCaseOutcome select(mapColumn(",
						"          APPEALINDICATOR,",
						"          CASEID,",
						"          CASETYPECODE,",
						"          CLASSIFICATIONCODE,",
						"          OBJECTIVECODE,",
						"          OUTCOMECODE,",
						"          PRIORITYCODE,",
						"          STATUSCODE,",
						"          INTEGRATEDCASETYPE,",
						"          CaseObj_DESCRIPTION,",
						"          CaseStatus_DESCRIPTION,",
						"          CasePriority_DESCRIPTION,",
						"          CaseOutcome_DESCRIPTION = DESCRIPTION",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectCaseOutcome",
						"SelectCaseOutcome, CaseCatTypeCode lookup(INTEGRATEDCASETYPE == CODE,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> LookupTypeCode",
						"LookupTypeCode select(mapColumn(",
						"          APPEALINDICATOR,",
						"          CASEID,",
						"          CASETYPECODE,",
						"          CLASSIFICATIONCODE,",
						"          OBJECTIVECODE,",
						"          OUTCOMECODE,",
						"          PRIORITYCODE,",
						"          STATUSCODE,",
						"          INTEGRATEDCASETYPE,",
						"          CaseObj_DESCRIPTION,",
						"          CaseStatus_DESCRIPTION,",
						"          CasePriority_DESCRIPTION,",
						"          CaseOutcome_DESCRIPTION,",
						"          CaseCatType_DESCRIPTION = DESCRIPTION",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectCaseCatTypeCode",
						"SelectCaseCatTypeCode, CaseClassification lookup(CLASSIFICATIONCODE == CODE,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> LookupClassification",
						"LookupClassification select(mapColumn(",
						"          APPEALINDICATOR,",
						"          CASEID,",
						"          CASETYPECODE,",
						"          CLASSIFICATIONCODE,",
						"          OBJECTIVECODE,",
						"          OUTCOMECODE,",
						"          PRIORITYCODE,",
						"          STATUSCODE,",
						"          INTEGRATEDCASETYPE,",
						"          CaseObj_DESCRIPTION,",
						"          CaseStatus_DESCRIPTION,",
						"          CasePriority_DESCRIPTION,",
						"          CaseOutcome_DESCRIPTION,",
						"          CaseCatType_DESCRIPTION,",
						"          CaseClass_DESCRIPTION = DESCRIPTION",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectClassification",
						"SelectClassification, CaseTypeCode lookup(CASETYPECODE == CODE,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> LookupCaseTypeCode",
						"LookupCaseTypeCode select(mapColumn(",
						"          APPEALINDICATOR,",
						"          CASEID,",
						"          CASETYPECODE,",
						"          CLASSIFICATIONCODE,",
						"          OBJECTIVECODE,",
						"          OUTCOMECODE,",
						"          PRIORITYCODE,",
						"          STATUSCODE,",
						"          INTEGRATEDCASETYPE,",
						"          CaseObj_DESCRIPTION,",
						"          CaseStatus_DESCRIPTION,",
						"          CasePriority_DESCRIPTION,",
						"          CaseOutcome_DESCRIPTION,",
						"          CaseCatType_DESCRIPTION,",
						"          CaseClass_DESCRIPTION,",
						"          CaseType_DESCRIPTION = DESCRIPTION",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> SelectCaseTypeCode",
						"srcCaseHeader derive(OBJECTIVECODE = trim(OBJECTIVECODE),",
						"          CASETYPECODE = trim(CASETYPECODE),",
						"          CLASSIFICATIONCODE = trim(CLASSIFICATIONCODE),",
						"          INTEGRATEDCASETYPE = trim(INTEGRATEDCASETYPE),",
						"          PRIORITYCODE = trim(PRIORITYCODE),",
						"          STATUSCODE = trim(STATUSCODE),",
						"          OUTCOMECODE = trim(OUTCOMECODE)) ~> TrimCodeFields",
						"SelectCaseTypeCode sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          Column_1 as string",
						"     ),",
						"     partitionFileNames:['CaseHeaderPOC'],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> DummyFile"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_CustomerDim_Parameters')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "This is not working as expected.",
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_EDWLoadControl",
								"type": "DatasetReference"
							},
							"name": "srcCustomerDimwParameters"
						},
						{
							"dataset": {
								"referenceName": "Customer_Test",
								"type": "DatasetReference"
							},
							"name": "source1"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "CustomerLoadTest",
								"type": "DatasetReference"
							},
							"name": "CustomerLoadTest"
						},
						{
							"dataset": {
								"referenceName": "Test_Date_Parameters",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "filter1"
						},
						{
							"name": "lookup1"
						}
					],
					"scriptLines": [
						"parameters{",
						"     BatchKey as string",
						"}",
						"source(output(",
						"          ProcessID as integer,",
						"          ProcessName as string,",
						"          StartDateTime as timestamp,",
						"          EndDateTime as timestamp,",
						"          BatchKey as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"SELECT StartDateTime ,EndDateTime ,BatchKey FROM dbo.EDW_Fact_Load_Control WHERE BatchKey='{$BatchKey}'\"),",
						"     format: 'query') ~> srcCustomerDimwParameters",
						"source(output(",
						"          CustomerID as integer,",
						"          NameStyle as boolean,",
						"          Title as string,",
						"          FirstName as string,",
						"          MiddleName as string,",
						"          LastName as string,",
						"          Suffix as string,",
						"          CompanyName as string,",
						"          SalesPerson as string,",
						"          EmailAddress as string,",
						"          Phone as string,",
						"          PasswordHash as string,",
						"          PasswordSalt as string,",
						"          rowguid as string,",
						"          ModifiedDate as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> source1",
						"srcCustomerDimwParameters filter(BatchKey==$BatchKey) ~> filter1",
						"source1, filter1 lookup(ModifiedDate >= StartDateTime,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'right')~> lookup1",
						"lookup1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          CustomerID as integer,",
						"          NameStyle as boolean,",
						"          Title as string,",
						"          FirstName as string,",
						"          MiddleName as string,",
						"          LastName as string,",
						"          Suffix as string,",
						"          CompanyName as string,",
						"          SalesPerson as string,",
						"          EmailAddress as string,",
						"          Phone as string,",
						"          PasswordHash as string,",
						"          PasswordSalt as string,",
						"          rowguid as string,",
						"          ModifiedDate as timestamp",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError') ~> CustomerLoadTest",
						"filter1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError') ~> sink1"
					]
				}
			},
			"dependsOn": []
		}
	]
}